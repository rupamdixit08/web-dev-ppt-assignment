{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset1 Segoe UI Symbol;}{\f2\froman\fprq2\fcharset0 Times New Roman;}{\f3\fswiss\fprq2\fcharset0 Segoe UI;}{\f4\fswiss\fprq2\fcharset0 Calibri;}}
{\colortbl ;\red55\green65\blue81;\red0\green255\blue255;\red217\green217\blue227;\red247\green247\blue248;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9\par
\f1\u-10179?\u-9055?\f0  **Q.1** What\rquote s difference between Synchronous and Asynchronous?\par
\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw15\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw15\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480\qc\cf1\b\f3\fs21\lang1033 Synchronous\cell Asynchronous\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480\b0 Executes tasks sequentially\cell Executes tasks concurrently/parallelly\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480 Blocks the program\cell Does not block the program\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480 One task at a time\cell Multiple tasks at a time\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480 Waits for task completion\cell Does not wait for task completion\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480 Can cause blocking behavior\cell Non-blocking behavior\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480 Simple control flow\cell Complex control flow\cell\row\trowd\trgaph15\trleft-60\trbrdrl\brdrs\brdrw5 \trbrdrt\brdrs\brdrw5 \trbrdrr\brdrs\brdrw5 \trbrdrb\brdrs\brdrw5 \trpaddl15\trpaddr15\trpaddfl3\trpaddfr3
\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw5\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx4502\clvertalb\clcbpat4\clbrdrl\brdrw15\brdrs\brdrcf3\clbrdrt\brdrw5\brdrs\brdrcf3\clbrdrr\brdrw15\brdrs\brdrcf3\clbrdrb\brdrw15\brdrs\brdrcf3 \cellx9735 
\pard\intbl\widctlpar\sb480\sa480 May lead to slower performance\cell May result in faster performance\cell\row 
\pard\sa200\sl276\slmult1\cf0\f0\fs22\lang9\par
    \par
  \f1\u-10179?\u-9055?\f0  **Q.2** What are Web Apis ?\par
Web APIs (Application Programming Interfaces) are a set of rules and protocols that allow different software applications to communicate with each other. In the context of web development, Web APIs refer to a collection of functions and interfaces that can be used to interact with web browsers, servers, and other web services.\par
Web APIs enable developers to access and manipulate various resources and functionalities provided by web browsers and servers. For example, the Document Object Model (DOM) API allows developers to access and modify the structure and content of a web page, while the XMLHttpRequest or Fetch API enables making HTTP requests to retrieve data from a server.\par
Web APIs are not specific to any particular programming language or platform. They provide a standardized way for different systems to interact with each other, enabling developers to create powerful web applications by leveraging the functionalities offered by these APIs.\par
\f1\u-10179?\u-9055?\f0  **Q.3** Explain SetTimeOut and setInterval ?\par
setTimeout and setInterval are functions in JavaScript used to schedule the execution of code after a certain delay.\par
The setTimeout function is used to execute a specified function or a block of code once after a specified delay. It takes two parameters: the function or code to be executed, and the delay in milliseconds. Here's an example:\par
setTimeout(() => \{\par
  console.log('This code executes after a delay of 2000 milliseconds.');\par
\}, 2000);\par
In this example, the code inside the arrow function will be executed after a delay of 2000 milliseconds (or 2 seconds).\par
The setInterval function is similar to setTimeout, but it repeatedly executes a function or a block of code at a specified interval. It also takes two parameters: the function or code to be executed, and the interval in milliseconds. Here's an example:\par
setInterval(() => \{\par
  console.log('This code executes every 1000 milliseconds.');\par
\}, 1000);\par
In this example, the code inside the arrow function will be executed every 1000 milliseconds (or 1 second), creating a repeating interval.\par
Both setTimeout and setInterval return a unique identifier that can be used to cancel the scheduled execution using the clearTimeout or clearInterval functions, respectively.\par
\f1\u-10179?\u-9055?\f0  **Q.4** how can you handle Async code in JavaScript ?\par
To handle asynchronous code in JavaScript, you have several options:\par
Callbacks: Callbacks are functions that are passed as arguments to other functions and are executed once the asynchronous operation is complete. This allows you to define what should happen after the asynchronous task finishes. However, using callbacks can lead to callback hell, which is a situation where callbacks are nested within each other, making the code hard to read and maintain.\par
Promises: Promises provide a more structured and readable way to handle asynchronous code. They represent a value that may not be available yet, but will be resolved in the future. Promises have methods like then() and catch() that allow you to chain operations and handle success and error cases respectively. Promises mitigate the callback hell problem and make asynchronous code more manageable.\par
Async/await: Async/await is a modern approach to handle asynchronous operations in JavaScript. It allows you to write asynchronous code that looks similar to synchronous code, making it easier to understand and maintain. The async keyword is used to define an asynchronous function, and the await keyword is used to wait for a promise to be resolved before proceeding. Async/await is built on top of promises and provides a more synchronous-like syntax.\par
\f1\u-10179?\u-9055?\f0  Q.5 What are Callbacks & Callback Hell?\par
Callbacks are functions that are passed as arguments to other functions and are executed once a particular operation is complete. They are commonly used in JavaScript to handle asynchronous code and ensure that certain tasks are executed in a specific order.\par
Callback Hell refers to a situation where multiple asynchronous operations are nested within each other, resulting in deeply nested callbacks. This can make the code difficult to read, understand, and maintain. Each nested callback relies on the result of the previous callback, leading to a pyramid-like structure of code.\par
Here's an example of Callback Hell:\par
asyncOperation1(function () \{\par
  // Callback of asyncOperation1\par
  asyncOperation2(function () \{\par
    // Callback of asyncOperation2\par
    asyncOperation3(function () \{\par
      // Callback of asyncOperation3\par
      // ...and so on\par
    \});\par
  \});\par
\});\par
This nesting of callbacks can make the code hard to follow and can lead to issues such as error handling and code duplication.\par
To avoid callback hell, modern JavaScript introduces promises and async/await, which provide more structured and readable ways to handle asynchronous code.\par
\par
\f1\u-10179?\u-9055?\f0  Q.6 What are Promises & Explain Some Three Methods of Promise?\par
Promises are objects in JavaScript used to represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They provide a way to handle asynchronous code in a more structured and manageable manner.\par
Promises have three states:\par
Pending: The initial state. The promise is neither fulfilled nor rejected.\par
Fulfilled: The asynchronous operation completed successfully, and the promise is resolved with a value. This value can be accessed using the then() method.\par
Rejected: The asynchronous operation failed, and the promise is rejected with a reason or an error. This reason can be accessed using the catch() method.\par
Promises have several methods to interact with them:\par
then(): The then() method is used to specify what should happen when a promise is fulfilled. It takes two optional callback functions as arguments: onFulfilled and onRejected. The onFulfilled callback is executed when the promise is fulfilled, and it receives the resolved value as its argument. The onRejected callback is executed when the promise is rejected, and it receives the reason for rejection as its argument.\par
\par
catch(): The catch() method is used to specify what should happen when a promise is rejected. It takes a callback function as an argument, which is executed when the promise is rejected. It is equivalent to calling then(null, onRejected).\par
finally(): The finally() method is used to specify a callback function that should be executed regardless of whether the promise is fulfilled or rejected. It allows you to define cleanup logic that should be performed after the completion of the promise, such as closing resources or releasing locks.\par
These methods can bechained together to handle the flow of asynchronous code and perform different actions based on the state of the promise. For example:\par
asyncTask()\par
  .then((result) => \{\par
    console.log('Promise fulfilled:', result);\par
    return anotherAsyncTask();\par
  \})\par
  .then((anotherResult) => \{\par
    console.log('Another promise fulfilled:', anotherResult);\par
  \})\par
  .catch((error) => \{\par
    console.log('Promise rejected:', error);\par
  \})\par
  .finally(() => \{\par
    console.log('Promise completed.');\par
  \});\par
In this example, asyncTask() and anotherAsyncTask() return promises. The then() method is used to handle the fulfillment of the promises and chain them together. If any promise is rejected, the catch() method is executed. The finally() method is called regardless of the fulfillment or rejection of the promises, allowing you to perform cleanup tasks.\par
\f1\u-10179?\u-9055?\f0  Q.7 What\rquote s async/await Keyword in JavaScript?\par
The async and await keywords in JavaScript are used together to handle asynchronous code in a more synchronous-like manner. They were introduced in ECMAScript 2017 (ES8) and provide a cleaner and more readable syntax for working with promises.\par
The async keyword is used to define an asynchronous function. An asynchronous function always returns a promise. Within an async function, you can use the await keyword to pause the execution of the function until a promise is fulfilled or rejected. The await keyword can only be used inside an async function.\par
\par
Here's an example:\par
\par
javascript\par
Copy code\par
async function fetchData() \{\par
  try \{\par
    const response = await fetch('https://api.example.com/data');\par
    const data = await response.json();\par
    console.log('Data:', data);\par
  \} catch (error) \{\par
    console.log('Error:', error);\par
  \}\par
\}\par
In this example, the fetchData() function is defined as an async function. Inside the function, the await keyword is used to pause the execution of the function until the fetch() request is resolved and the response is received. Similarly, the await keyword is used to wait for the response.json() method to parse the response data.\par
\par
Using async/await makes the code appear more synchronous, making it easier to read and understand the flow of asynchronous operations.\par
\par
\f1\u-10179?\u-9055?\f0  Q.8 Explain the purpose of the Try and Catch block & why do we need it?\par
\par
The try and catch blocks are used in JavaScript for error handling. They allow you to catch and handle exceptions (errors) that occur during the execution of a block of code.\par
\par
The try block encloses the code that might throw an exception. If an exception occurs within the try block, it is thrown and immediately caught by the catch block. The catch block contains the code that handles the exception, allowing you to gracefully deal with errors and prevent the program from crashing.\par
\par
Here's an example:\par
\par
javascript\par
Copy code\par
try \{\par
  // Code that might throw an exception\par
  const result = divide(10, 0);\par
  console.log('Result:', result);\par
\} catch (error) \{\par
  // Code that handles the exception\par
  console.log('Error:', error.message);\par
\}\par
In this example, the divide() function divides two numbers. If the second argument is 0, it will throw an exception. The try block wraps the divide() function call, and the catch block catches the exception and logs the error message.\par
\par
The purpose of the try and catch block is to provide a mechanism for handling errors in a controlled manner. It allows you to gracefully handle exceptions and prevent the program from crashing or producing unexpected behavior. By catching and handling exceptions, you can perform error recovery, display meaningful error messages to users, or execute alternative code paths.\par
\par
\f1\u-10179?\u-9055?\f0  Q.9 Explain fetch.\par
\par
fetch is a built-in function in JavaScript used to make HTTP requests to fetch resources from a server. It provides a modern alternative to the traditional XMLHttpRequest object for making network requests.\par
The fetch function returns a promise that resolves to the Response object representing the response to the request. The Response object contains methods and properties to handle the response data, such as json(), text(), and blob(), among others.\par
Here's an example of using fetch to make a GET request and retrieve JSON data:\par
fetch('https://api.example.com/data')\par
  .then((response) => response.json())\par
  .then((data) => \{\par
    console.log('Data:', data);\par
  \})\par
  .catch((error) => \{\par
    console.log('Error:', error);\par
  \});\par
In this example, fetch is called with the URL of the API endpoint. The first then() method is used to parse the response data as JSON. The second then() method receives the parsed JSON data and logs it. The catch() method is used to handle any errors that occur during the request.\par
fetch supports various options to customize the request, such as setting headers, specifying request methods, including request bodies, and more. It is widely used in web development to interact with APIs and retrieve data from servers.\par
\f1\u-10179?\u-9055?\f0  Q.10 How do you define an asynchronous function in JavaScript using async/await?\par
To define an asynchronous function in JavaScript using async/await, you need to use the async keyword before the function declaration. An asynchronous function always returns a promise, which can be awaited using the await keyword.\par
Here's an example:\par
async function fetchData() \{\par
  try \{\par
    const response = await fetch('https://api.example.com/data');\par
    const data = await response.json();\par
    console.log('Data:', data);\par
  \} catch (error) \{\par
    console.log('Error:', error);\par
  \}\par
\}\par
In this example, the fetchData() function is defined as an asynchronous function using the async keyword. Inside the function, the await keyword is used to wait for the asynchronous operations to complete.\par
Note that when an async function is called, it returns a promise that resolves to the value returned by the function or rejects with an error thrown inside the function. This allows you to use then() and catch() to handle the result or error of the async function, just like any other promise.\par
fetchData()\par
  .then(() => \{\par
    console.log('Async function completed successfully.');\par
  \})\par
  .catch((error) => \{\par
    console.log('Async function failed:', error);\par
  \});\par
In this example, the then() method is used to handle the successful completion of the fetchData() function, and the catch() method is used to handle any errors that occur during the function execution.\par
\f1\u-10179?\u-9055?\f0  **Q.5** What are Callbacks &  Callback Hell ?\par
Callbacks are functions that are passed as arguments to other functions and are executed once a particular operation is complete. They are commonly used in JavaScript to handle asynchronous code and ensure that certain tasks are executed in a specific order.\par
Callback Hell refers to a situation where multiple asynchronous operations are nested within each other, resulting in deeply nested callbacks. This can make the code difficult to read, understand, and maintain. Each nested callback relies on the result of the previous callback, leading to a pyramid-like structure of code.\par
Here's an example of Callback Hell:\par
asyncOperation1(function () \{\par
  // Callback of asyncOperation1\par
  asyncOperation2(function () \{\par
    // Callback of asyncOperation2\par
    asyncOperation3(function () \{\par
      // Callback of asyncOperation3\par
      // ...and so on\par
    \});\par
  \});\par
\});\par
This nesting of callbacks can make the code hard to follow and can lead to issues such as error handling and code duplication.\par
To avoid callback hell, modern JavaScript introduces promises and async/await, which provide more structured and readable ways to handle asynchronous code.\par
\f1\u-10179?\u-9055?\f0  **Q.6** What are Promises & Explain Some Three Methods of Promise\par
Promises are objects in JavaScript used to represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They provide a way to handle asynchronous code in a more structured and manageable manner.\par
\par
Promises have three states:\par
Pending: The initial state. The promise is neither fulfilled nor rejected.\par
Fulfilled: The asynchronous operation completed successfully, and the promise is resolved with a value. This value can be accessed using the then() method.\par
Rejected: The asynchronous operation failed, and the promise is rejected with a reason or an error. This reason can be accessed using the catch() method.\par
Promises have several methods to interact with them:\par
then(): The then() method is used to specify what should happen when a promise is fulfilled. It takes two optional callback functions as arguments: onFulfilled and onRejected. The onFulfilled callback is executed when the promise is fulfilled, and it receives the resolved value as its argument. The onRejected callback is executed when the promise is rejected, and it receives the reason for rejection as its argument.\par
catch(): The catch() method is used to specify what should happen when a promise is rejected. It takes a callback function as an argument, which is executed when the promise is rejected. It is equivalent to calling then(null, onRejected).\par
finally(): The finally() method is used to specify a callback function that should be executed regardless of whether the promise is fulfilled or rejected. It allows you to define cleanup logic that should be performed after the completion of the promise, such as closing resources or releasing locks.\par
Example:\par
asyncTask()\par
  .then((result) => \{\par
    console.log('Promise fulfilled:', result);\par
    return anotherAsyncTask();\par
  \})\par
  .then((anotherResult) => \{\par
    console.log('Another promise fulfilled:', anotherResult);\par
  \})\par
  .catch((error) => \{\par
    console.log('Promise rejected:', error);\par
  \})\par
  .finally(() => \{\par
    console.log('Promise completed.');\par
  \});\par
\par
\f1\u-10179?\u-9055?\f0  **Q.7** What\rquote s async & await Keyword in JavaScript\par
The async and await keywords in JavaScript are used together to handle asynchronous code in a more synchronous-like manner. They were introduced in ECMAScript 2017 (ES8) and provide a cleaner and more readable syntax for working with promises.\par
The async keyword is used to define an asynchronous function. An asynchronous function always returns a promise. Within an async function, you can use the await keyword to pause the execution of the function until a promise is fulfilled or rejected. The await keyword can only be used inside an async function.\par
Here's an example:\par
async function fetchData() \{\par
  try \{\par
    const response = await fetch('https://api.example.com/data');\par
    const data = await response.json();\par
    console.log('Data:', data);\par
  \} catch (error) \{\par
    console.log('Error:', error);\par
  \}\par
\}\par
In this example, the fetchData() function is defined as an async function. Inside the function, the await keyword is used to pause the execution of the function until the fetch() request is resolved and the response is received. Similarly, the await keyword is used to wait for the response.json() method to parse the response data.\par
Using async/await makes the code appear more synchronous, making it easier to read and understand the flow of asynchronous operations.\par
\par
\f1\u-10179?\u-9055?\f0  **Q.8** Explain Purpose of Try and Catch Block & Why do we need it?\par
he try and catch blocks are used in JavaScript for error handling. They allow you to catch and handle exceptions (errors) that occur during the execution of a block of code.\par
The try block encloses the code that might throw an exception. If an exception occurs within the try block, it is thrown and immediately caught by the catch block. The catch block contains the code that handles the exception, allowing you to gracefully deal with errors and prevent the program from crashing.\par
Here's an example:\par
try \{\par
  // Code that might throw an exception\par
  const result = divide(10, 0);\par
  console.log('Result:', result);\par
\} catch (error) \{\par
  // Code that handles the exception\par
  console.log('Error:', error.message);\par
\}\par
\par
\f1\u-10179?\u-9055?\f0  **Q.9** Explain fetch\par
fetch is a built-in function in JavaScript used to make HTTP requests to fetch resources from a server. It provides a modern alternative to the traditional XMLHttpRequest object for making network requests.\par
The fetch function returns a promise that resolves to the Response object representing the response to the request. The Response object contains methods and properties to handle the response data, such as json(), text(), and blob(), among others.\par
Here's an example of using fetch to make a GET request and retrieve JSON data:\par
fetch('https://api.example.com/data')\par
  .then((response) => response.json())\par
  .then((data) => \{\par
    console.log('Data:', data);\par
  \})\par
  .catch((error) => \{\par
    console.log('Error:', error);\par
  \});\par
\f1\u-10179?\u-9055?\f0  **Q.10** How do you define an asynchronous function in JavaScript using async/await?\par
async keyword before the function declaration. An asynchronous function always returns a promise, which can be awaited using the await keyword.\par
Here's an example:\par
async function fetchData() \{\par
  try \{\par
    const response = await fetch('https://api.example.com/data');\par
    const data = await response.json();\par
    console.log('Data:', data);\par
  \} catch (error) \{\par
    console.log('Error:', error);\par
  \}\par
\}\par
In this example, the fetchData() function is defined as an asynchronous function using the async keyword. Inside the function, the await keyword is used to wait for the asynchronous operations to complete.\par
 when an async function is called, it returns a promise that resolves to the value returned by the function or rejects with an error thrown inside the function. This allows you to use then() and catch() to handle the result or error of the async function, just like any other promise.\par
Example-\par
fetchData()\par
  .then(() => \{\par
    console.log('Async function completed successfully.');\par
  \})\par
  .catch((error) => \{\par
    console.log('Async function failed:', error);\par
  \});\par
\par
\par
\par
}
 